#include "decode.h"

#define QUIET_THRESHOLD    1.7
#define GOERZTEL_THRESHOLD 180

static struct ToneMap TONEMAP[16]
    = { { 697, 1209, '1' }, { 697, 1336, '2' }, { 697, 1477, '3' },
        { 697, 1633, 'A' }, { 770, 1209, '4' }, { 770, 1336, '5' },
        { 770, 1477, '6' }, { 770, 1633, 'B' }, { 852, 1209, '7' },
        { 852, 1336, '8' }, { 852, 1477, '9' }, { 852, 1633, 'C' },
        { 941, 1209, '*' }, { 941, 1336, '0' }, { 941, 1477, '#' },
        { 941, 1633, 'D' } };

static Frequency_t low[4] = {
  { 697, 0.8538689046744509 * 2 },
  { 770, 0.8226405180208598 * 2 },
  { 852, 0.78434349193341 * 2 },
  { 941, 0.7391022841200879 * 2 },
};

static Frequency_t high[4] = {
  { 1209, 0.5820520115136658 * 2 },
  { 1336, 0.49818510533949084 * 2 },
  { 1477, 0.3993091946133181 * 2 },
  { 1633, 0.284266353387601 * 2 },
};

char toneDetection(short low_freq, short high_freq) {
  // Loop variable
  int i = 0;

  // Loop through the array of ToneMaps
  for (i = 0; i < 16; ++i) {
    // Check if the low and high frequencies match the tone
    if (TONEMAP[i].low_freq == low_freq && TONEMAP[i].high_freq == high_freq) {
      // If they do, return the tone char
      return TONEMAP[i].tone;
    }
  }

  // Return null character if not matched tone
  return '\0';
}

float quietDetection(float* samples, unsigned short size) {
  // Loop variable
  int i = 0;
  // Stores the sum of absolute sample values
  float amplitudesum = 0;

  // Iterate over the samples within the specified range
  for (i = 0; i < size; i++) {
    // Add the absolute value of the sample to the sum
    amplitudesum += (samples[i] < 0) ? -samples[i] : samples[i];
  }

  // Return the sum of absolute sample values
  return amplitudesum;
}

float processSample(float* samples, unsigned short size, Frequency_t freq) {
  // Loop variable
  int i = 0;
  // Initialize state variables q0, q1, and q2
  float q0 = 0, q1 = 0, q2 = 0;

  // Iterate over the signal segment
  for (i = 0; i < size; ++i) {
    // Compute the new value of q0 using the filter equation
    q0 = samples[i] + (freq.cosw * q1) - q2;
    // freq.cosw is actually 2 * the cos

    // Update q2 and q1 for the next iteration
    q2 = q1;
    q1 = q0;
  }

  return (q1 * q1) + (q2 * q2) - (freq.cosw * q1 * q2);
}

char decode(float* buffer, unsigned short size) {
  int i = 0;
  unsigned char low_found = 0, high_found = 0;
  float low_freq_mag = 0, high_freq_mag = 0;
  float low_freq_highest = 0, high_freq_highest = 0;
  short lowest_freq = 0, highest_freq = 0;

  // Start of decoded algorithm
  if (quietDetection(buffer, size) < (float) QUIET_THRESHOLD) {
    return '\0';
  }

  for (i = 0; i < 4; ++i) {
    // Low freq
    low_freq_mag = processSample(buffer, size, low[i]);
    if (low_freq_mag > GOERZTEL_THRESHOLD) {
      if (low_found) {
        return '\0';
      }

      if (low_freq_mag < low_freq_highest) {
        continue;
      }

      low_found = 1;
      low_freq_highest = low_freq_mag;
      lowest_freq = low[i].frequency;
    }

    // High freq
    high_freq_mag = processSample(buffer, size, high[i]);
    if (high_freq_mag > GOERZTEL_THRESHOLD) {
      if (high_found) {
        return '\0';
      }

      if (high_freq_mag < high_freq_highest) {
        continue;
      }

      high_found = 1;
      high_freq_highest = high_freq_mag;
      highest_freq = high[i].frequency;
    }
  }

  return toneDetection(lowest_freq, highest_freq);
}
