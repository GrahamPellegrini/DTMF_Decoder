\documentclass{cce2014-design}
\svnInfo $Id$

% Document details
\title{Design Brief: Group 5}
\author{
   Matthew Mifsud,
   Luca Vella,
   Graham Pellegrini,
   Julian Falzon
   }
\date{\svnMaxToday, Document v.\svnInfoMaxRevision}

\begin{document}

\maketitle

\abstract{%
   This documentation outlines the design of a project utilizing the LPC4088 microcontroller to interpret telephone keypad presses, also known as Dual-Tone Multi-Frequency (DTMF) signals. The LPC4088 will sample and process these signals, enabling the display of results on an LCD and feedback through two status LEDs. Additionally, users will be able to configure the display state using a switch.
}

\section{Introduction}
Dual-tone multi-frequency (DTMF) signaling is a method used in telecommunication systems to transmit digits or symbols over telephone lines. It utilizes pairs of audio frequencies to represent each symbol, which include the digits from 0 to 9, the letters A to D, and special characters such as * and \#. Each symbol is encoded using a unique pair of frequencies, consisting of one low and one high frequency. Importantly, these frequency pairs are chosen from within the voice frequency range, making them audible. \cite{DTMF_Wikipedia}.

\begin{table}[h!]
   \begin{center}
      \begin{tabular}{ |c|c|c|c|c| }
         \hline
         Freq  & 1209Hz & 1336Hz & 1477Hz & 1633Hz \\
         \hline
         697Hz & 1      & 2      & 3      & A      \\
         \hline
         770Hz & 4      & 5      & 6      & B      \\
         \hline
         852Hz & 7      & 8      & 9      & C      \\
         \hline
         941Hz & *      & 0      & \#     & D      \\
         \hline
      \end{tabular}
      \caption{Frequency Mappings}
      \label{table:frequencies}
   \end{center}
\end{table}

The project assigned aims to build a DTMF decoder utilizing an ARM Cortex-M4 microcontroller, capable of processing line-level audio inputs with different signal characteristics. This includes handling inputs with perfect timing (fixed duration), inputs with imperfect timing (small random variations in duration), and noisy, imperfect inputs. The system will then decode these signals and display the results on an external LCD screen in real time.

The design is structured to proceed through a defined sequence of steps. The following documentation aims to present a comprehensive overview of the design process by briefly going through each step in the sequence to ensure a thorough understanding of the approach to the problem.

\section{System Design}
\subsection{Hardware Components}
\textbf{Line output to ADC Circuit (input)}:
A DTMF audio source will be sent to the device from a computer by using the headphone jack line output as input to the ADC. The audio signals used for testing and implementation will be those sourced from VLE as .mp3 files with variations in signal properties.
However, since line output signals vary nominally between approximately -1V to 1V and the wanted ADC signal to be processed needs to vary from 0V to VREF  (where VREF is the working voltage from the microcontroller LPC4088) then an intermediate circuit needs to be built \cite{ADC_stackexchange}.

\begin{figure}[!ht]
   \centering
   \includegraphics[width=0.4\textwidth]{ADC_Circuit.png}
   \caption{Line output to ADC}
\end{figure}

Breaking the circuit down:
\begin{enumerate}
   \item Firstly, the audio line output signal is passed serially through a 100nF capacitor which acts as an open circuit for the DC component of the signal. Thereby, allowing only the AC component of the signal to pass.
   \item Secondly, a serial 100-ohm resistor is used to simply limit circuit current.
   \item At the first junction a voltage divider containing two 10K-ohm resistors is used \cite{VoltageDividerWiki}. Thus, halving the input voltage range spanning from VREF to ground and placing the signal within the suitable range for the ADC.
   \item A parallel second junction to the voltage divider of two respective 1N4148 diodes is used to protect the circuit from overvoltage (falling outside the ADC range) \cite{1n4148-datasheet}. If one input exceeds the ADC range then the opposite polar diode will begin to conduct and negate the excess voltage.
   \item Finally an ADC-appropriate signal is achieved.
\end{enumerate}

\begin{figure}[!ht]
   \centering
   \includegraphics[width=0.4\textwidth]{LinetoADC.png}
   \caption{Line and ADC signals}
\end{figure}

Therefore, the circuit described above serves as an input conditioning stage for the audio signal before it enters the WM8731 codec. The ADC in the WM8731 converts the analog audio signal into digital format, which can then be processed digitally by a microcontroller. The values produced by the onboard codec can be directly read through the memory-mapped I/O on the LPC4088 microcontroller board.

\textbf{User Interaction Switch}:
A switch will be used to facilitate user interaction with the system. This includes modifying system settings to enable/disable scrolling and clearing the LCD. This will be done through the GPIO pins which connect the switch to the LPC4088 microcontroller, which in turn monitors the state of the switch and takes appropriate actions based on user input.

\textbf{Liquid-crystal display}:
The Hitachi HD44780-based 16x2 LCD is interfaced with the LPC4088 microcontroller using GPIO pins for data signals, control signals, and power connections (VCC and GND) \cite{hd44780-datasheet}. The microcontroller will send commands and data to the LCD in order to display the decoded output to the user.

\textbf{Feedback LEDs}:
Two LEDs connected through the GPIO pins will provide visual user feedback on the system state. A green LED will indicate that the system is in a safe defined state, whilst a red LED will indicate an error.

\emph{Note: All additional hardware components were sourced by the Computer Engineer through the electronics supplier 'Fabian Enterprises Ltd'}

\subsection{Interrupt-Driven Sampling}
The system will be multithreaded by emulating two threads, a read and a decode (main) thread, through the use of a timer that calls an interrupt handler that triggers the ADC to sample the input signal at a frequency of at least 3266Hz. The sample rate was chosen based on the Nyquist theorem, which states that the rate should be at least twice the highest frequency of the signal, for accurate measurement.

\subsection{Buffer store}
Each captured sample is immediately stored in a circular buffer on the system's RAM which overwrites the oldest data once full capacity has been reached.

\begin{figure*}[!ht]
   \centering
   \includegraphics[width=1\textwidth]{UML.png}
   \caption{UML Diagram of Required Components / Classes}
   \hrulefill
\end{figure*}

\subsection{Functional Requirements}
\begin{description}
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} Solution must be real-time; reacting to one or more inputs that can change at any time.\vspace{2mm}}] \underline{Description:} The system will constantly read input signals, allow the user to clear display, and set configurations using a switch. Using the ARM MDK this will either be done in the main loop through constant checks or through interrupts. In this way, the system can react to real time inputs.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must make use of at least one digital input.\vspace{2mm}}] \underline{Description:} The system will contain a switch with multiple functionalities. A press clears the LCD display, thus resetting it for a new input sequence, and a toggle-up enables/disables automatic scrolling. Using the MDK this will be achieved using the GPIO drivers which facilitate configuring and using inputs such as switches.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must make use of at least one digital output.\vspace{2mm}}] \underline{Description:} The system will make use of two LEDs (1 red and 1 green) to provide immediate visual feedback of the system status. Under normal and safe operation, the green LED emits light. Upon detection of any error (such as decoding failure), the red LED will instead emit light. This will be done through the MDK's GPIO drivers which provide control to the LEDs' on and off state.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must connect to at least one external peripheral.\vspace{2mm}}] \underline{Description:} A Hitachi HD44780-based 16x2 LCD display will be used to output the decoded result. This can be achieved through manipulating GPIO pins to communicate with the LCD. These are pin P1\mathunderscore24 (used for serial data input), pin P1\mathunderscore20 (acts as the clock signal for synchronizing data transmission) and pin P1\mathunderscore2 (signals the transfer of data from the shift register to the output latches).
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} On power up or reset, system should enter a well‚Äêdefined safe state.\vspace{2mm}}] \underline{Description:} The aim is that using the MDK, routines will be defined to only respond to valid inputs, thus the system will be designed to never enter an undefined state.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must persistently store configuration settings, independent of the position of physical switches.\vspace{2mm}}] \underline{Description:}  The ARM MDK supports interfacing with non-volatile memory devices such as flash memory and EEPROMs. Thus either one will be used in order to keep track of the configurations set by the user.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System shall have a useful and appropriate mechanism for indicating error conditions to the user.\vspace{2mm}}] \underline{Description:} As mentioned previously, a red LED will be controlled using the MDK to indicate that the system has encountered an error.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System should be robust (incorrect input is handled)\vspace{2mm}}] \underline{Description:} In the event of incorrect input, the system will ignore the input without performing any action, ensuring that it remains in a stable and expected state.
\end{description}

\subsection{Steps required for decoding a signal}
\begin{enumerate}
   \item Analogue-to-digital conversion: Continuous analog signals are sampled using the ADC and stored in the RAM buffer.
   \item Noise filtering using convolution: In order to enhance signal a filter is applied such that only frequencies within the DTMF range are allowed.
   \item Breaking up the frequency: In order to identify the two frequencies making up the signal, either the Goertzel algorithm or the Fast Fourier Transform will be used.
   \item Map frequencies to digits: Once a pair of frequencies has been obtained, they are matched to the corresponding result using a lookup table. For example, the frequency pair 697, and 1209 corresponds to the digit '1'.
   \item Output Display: The decoded result is then sent directly to the display module's memory such that it is displayed to the user in real time.
\end{enumerate}

\section{Management}
\subsection{Time Plan and Dependencies}
We have identified 11 tasks which need to be tackled. These tasks can be seen in the legend on the left-hand side of the Gantt Chart\cite{GANTT_Wikipedia} figure (Fig \ref*{figure:ganttChart}).

\begin{figure}[!ht]
   \centering
   \includegraphics[width=0.45\textwidth]{GanttChart.png}
   \caption{Gantt Chart showing our proposed time plan}
   \label{figure:ganttChart}
\end{figure}

The required responsibilities were assigned among the members of the group. These responsibilities may be subject to changes as we proceed further. Below is a breakdown of our planned assignments:

\begin{enumerate}
   \item Graham Pellegrini is assigned: Primarily the External Audio Input Circuit, Secondarily Signal Cleaning, Thirdly The Decoding Algorithm
   \item Luca Vella is assigned: Primarily ADC Sampling, Secondarily Mapping to Characters, LED Operation.
   \item Matthew Mifsud is assigned: Primarily Displaying to Screen, Secondarily ADC Sampling, Thirdly Switch Operation.
   \item Julian Falzon is assigned: Primarily the Decoding Algorithm, Secondarily Configuration Settings.
\end{enumerate}

By 'Further Additions' we are referring to the implementation of any extra features that are not crucial to the functionality of the core DTMF decoder.
On the other hand, by 'Refinements' we mean optimization and refactoring of the code.
Thus, there will be no particular individual assigned for these tasks.

It should be noted that the tasks in the chart were chosen to have a one or two-week deadline, with the decoding algorithm taking three weeks, depending on the complexity of the task.

The tasks in the chart are staggered such that they partially depend on the tasks above.
The arrows within the chart illustrate which parts require full functionality of a particular task before being able to move forward.
For example, a portion of task 2 depends on task 1, this could be the testing of whether input can be read.

\subsection{Development Model}
The Rapid Software Development model is selected for this project. This model involves dividing the project into smaller, manageable parts that can be developed and tested in brief, iterative cycles. Thus emphasizing speedy development, which is a fitting choice since some decisions may change and evolve.
\cite{RapidDev}

\section{Closure}
In conclusion, this design brief has outlined the challenges to be tackled and initiated a plan for solutions to meet all requested requirements. Preliminary specifications for implementation have been set in order to do so. It is important to note that these specifications, such as error handling, the structure of component classes, and other proposed solutions may be restructured or better adapted later on in the implementation timeline. Tasks have also been set out individually, however, a collaborative effort is expected from all members in order to enable more effective problem-solving.

\bibliographystyle{ieeetr}
\bibliography{references}

\end{document}