\documentclass{cce2014-design}
\svnInfo $Id$

% Document details
\title{Design Brief: Group 5}
\author{
   Matthew Mifsud,
   Luca Vella,
   Graham Pellegrini,
   Julian Falzon
   }
\date{\svnMaxToday, Document v.\svnInfoMaxRevision}

\begin{document}

\maketitle

\abstract{%
   This documentation outlines the design of a project utilizing the LPC4088 microcontroller to interpret telephone keypad presses, also known as Dual-Tone Multi-Frequency (DTMF) signals. The LPC4088 will sample and process these signals, enabling the display of results on an LCD and feedback through two status LEDs. Additionally, users will be able to configure the display state using a switch.
}

\section{Introduction}
Dual-tone multi-frequency (DTMF) signaling is a method used in telecommunication systems to transmit digits or symbols over telephone lines. It utilizes pairs of audio frequencies to represent each symbol, which include the digits from 0 to 9, the letters A to D, and special characters such as * and \#. Each symbol is encoded using a unique pair of frequencies, consisting of one low and one high frequency. Importantly, these frequency pairs are chosen from within the voice frequency range, making them audible. \cite{DTMF_Wikipedia}.

\begin{table}[h!]
   \begin{center}
      \begin{tabular}{ |c|c|c|c|c| }
         \hline
         Freq  & 1209Hz & 1336Hz & 1477Hz & 1633Hz \\
         \hline
         697Hz & 1      & 2      & 3      & A      \\
         \hline
         770Hz & 4      & 5      & 6      & B      \\
         \hline
         852Hz & 7      & 8      & 9      & C      \\
         \hline
         941Hz & *      & 0      & \#     & D      \\
         \hline
      \end{tabular}
      \caption{Frequency Mappings}
      \label{table:frequencies}
   \end{center}
\end{table}

The project assigned aims to build a DTMF decoder utilizing an ARM Cortex-M4 microcontroller, capable of processing line-level audio inputs with different signal characteristics. This includes handling inputs with perfect timing (fixed duration), inputs with imperfect timing (small random variations in duration), and noisy, imperfect inputs. The system will then decode these signals and display the results on an external LCD screen in real time.

The design is structured to proceed through a defined sequence of steps. The following documentation aims to present a comprehensive overview of the design process by briefly going through each step in the sequence to ensure a thorough understanding of the approach to the problem.
\pagebreak

\section{System Design}
\subsection{Hardware Components}
\subsubsection{Line output to ADC Circuit (input)}:
\textbf{Theory}
A DTMF audio source will be sent to the device from a computer by using the headphone jack line output as input to the ADC. The audio signals used for testing and implementation will be those sourced from VLE as .mp3 files with variations in signal properties.
However, since line output signals vary nominally between approximately -1V to 1V and the wanted ADC signal to be processed needs to vary from 0V to VREF  (where VREF is the working voltage from the microcontroller LPC4088) then an intermediate circuit needs to be built \cite{ADC_stackexchange}.

\begin{figure}[!ht]
   \centering
   \includegraphics[width=0.4\textwidth]{ADC_Circuit.png}
   \caption{Line output to ADC}
\end{figure}

Breaking the circuit down:
\begin{enumerate}
   \item Firstly, the audio line output signal is passed serially through a 100nF capacitor which acts as an open circuit for the DC component of the signal. Thereby, allowing only the AC component of the signal to pass.
   \item Secondly, a serial 100-ohm resistor is used to simply limit circuit current.
   \item At the first junction a voltage divider containing two 10K-ohm resistors is used \cite{VoltageDividerWiki}. Thus, halving the input voltage range spanning from VREF to ground and placing the signal within the suitable range for the ADC.
   \item A parallel second junction to the voltage divider of two respective 1N4148 diodes is used to protect the circuit from overvoltage (falling outside the ADC range) \cite{1n4148-datasheet}. If one input exceeds the ADC range then the opposite polar diode will begin to conduct and negate the excess voltage.
   \item Finally an ADC-appropriate signal is achieved.
\end{enumerate}

\begin{figure}[!ht]
   \centering
   \includegraphics[width=0.4\textwidth]{LinetoADC.png}
   \caption{Line and ADC signals}
\end{figure}

Therefore, the circuit described above serves as an input conditioning stage for the audio signal before the output signal is passed to the LPC4088 expriment board through the respective ADC pin in. The values passed through the ADC in can then be read as scalled bits from the memory allocation indexed.\\

\textbf{Implementation}
The issue faced and previously discussed was the need to convert the line level output recived from the headphone jack to a voltage level that can be read by the ADC. \\

On implementation of the required circuit, the respective components were acuired and the circuit was assembled following the schematic provided. The circuit was tested with an oscilloscope to ensure that the output was being centered correctly between the 0 and $V_{ref}$ levels. Testing before trying to connect directly to the microcontroller was done to ensure that no damage would be done to the microcontroller and the adc components.\\

The inital implementation of the circuirt indeed did not work fully as expected, due to one of the 1N4148 diodes being blown out. This initially lead to the belief that the diodes orientation were incorrect. However, after testing the diodes seperately and replacing the blown diode, the circuit was tested again and the output was as expected. 

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.7\linewidth]{vref.jpg}
    \caption{Voltage Supply set for Vref}
    \label{fig1}
\end{figure}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\linewidth]{circuit.jpg}
    \caption{Circuit Implementation}
    \label{fig2}
\end{figure}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\linewidth]{shifted_difference.jpg}
    \caption{Circuit Implementation}
    \label{fig3}
\end{figure}

In figure \ref{fig3}, the output of a quite region without the respective circuirt connections is shown. In the plot, the cursor indicates the required region that the output should be centered around. However, it is clear that the output is not centered around the required region.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\linewidth]{quite_shifted.jpg}
    \caption{Circuit Implementation}
    \label{fig4}
\end{figure}

In figure \ref{fig4}, we can see the same quite signal with the circuit connected. The output is now centered around the required region. Indicating that the circuit is working as expected and that the output signal should be able to be read by the ADC.


\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\linewidth]{jack_connections.jpg}
    \caption{Jack Connections}
    \label{fig5}
\end{figure}

In figure \ref{fig5}, the direct connection of the headphone jack output to the oscilloscope is shown. This is done by identitfying the left,right and ground connections of the headphone jack and connecting the respective oscilloscope probes to the ground and right/left connections. Knowing that the output is a stereo signal, the left and right channels were tested seperately, but results were the same.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\linewidth]{signal_unshifted.jpg}
    \caption{Unshifted Signal}
    \label{fig6}
\end{figure}

In figure \ref{fig6}, the output of a signal being played through the headphone jack connection is shown in figure \ref{fig5}. The output is not centered around the required region and the signal is not able to be read by the ADC. 

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\linewidth]{signal_shifted.jpg}
    \caption{Shifted Signal}
    \label{fig7}
\end{figure}

In figure \ref{fig7}, the output of a signal is now connected to the circuit. Comparing to figure \ref{fig6}, the output is now centered around the required region and the signal is able to be read by the ADC. However, in both figures it was noted that the signal power recived is relatively low. This is due to the player properties at the laptop output, even when the volume is set to max. A solution to this was to use a different source player such as an mp3 player or phone with a higher output power. The implementation of a amplifier in the circuit was also discussed. However, the adc was still able to read the signal and the power was sufficient for the purposes of the project. Therefore, the complication of adding an amplifier was not persued, in order to keep the circuirt as simple as possible. This was an engineering desicion made to keeping the project within scope and simplicity.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\linewidth]{pin_config.png}
    \caption{Pin Configuration}
    \label{fig8}
\end{figure}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.6\linewidth]{board_connections.jpg}
    \caption{On Board Connections}
    \label{fig9}
\end{figure}

From the provided LPC4088 board manuals, the respective pin configurations for $V_{out}$ which is our $V_{ref}$ of 3.3, grounds and ADC in pins were identified. The pins identified are highlighted in figure \ref{fig8}. The connections were made on the board as shown in figure \ref{fig9}. The connections were made to the respective pins on the board and the circuit was tested. Having the adc properly configured and the connections made, the adc was able to read the signal and map it to the 4096 levels of the adc. The signal digital value was then printed and observed accordingly.
\pagebreak

\subsubsection{User Interaction Switch}:
\textbf{Theory}
A switch will be used to facilitate user interaction with the system. This includes modifying system settings to enable/disable scrolling and clearing the LCD. This will be done through the GPIO pins which connect the switch to the LPC4088 microcontroller, which in turn monitors the state of the switch and takes appropriate actions based on user input.\\

\textbf{Implementation}
Within system operation the switch is used to perfom various tasks. The respective switch inputs are read using the switch driver function to identitfy any switch directional inputs if any, every main funtional iteration. In the implementation of the switch inputs all inputs are used to toggle an opertions. The respective operations for the switch inputs are:

\beign{itemize}
   \item Switch UP - Toggles autoscroll value, erasing the previous EEPROM value stored and writing to it the new value. This value is a flag and is only one bit. The autoscroll functionality manages how the LCD display prints to screen. Having 0 value clear screen and print at the top again when screen is full, whilst the 1 value shifts last line up and writes below creating a scrolling adaptation. When the autoscroll is being set the respective blue light indication must also be set, unless in the adc value state where a constant white light indication must be seen.
   
   \item Switch CENTER - Clears the screen for the lcd display. Simply calling the lcd clear fucntion and resetting the cursor position. The center switch also indicates a clear of screen with a flash of a green light on the led indicator.
   
   \item Switch DOWN - Terminate program. The switch down clears display, displays a "Goodbye" termination indication on screen and exits the program from further decoding or functionalities. The system may be restarted through the respective reset button and the flashed system is rerun from start.
   
   \item Switch RIGHT - Terminate program. Same implementation as switch DOWN.
   
   \item Switch LEFT - Toggles the adc value flag, to enter a debugging state for the potentiometer value. ADC readings might be effected by the on board, hardwired potentiometer. So a respective interface to be able to see and set remove effect of potentiometer is present. Here the adc value is toggled and the respective white light is indicated on the led indicator. Note we must also reset cursor position for the displaying of ADC values.
\end{itemize}

Each iteration of the main fucntion the switch get switch input fucntion from the respective driver is called. A sequence of if and else if statements are check to toggle respective operations. It is to be noted that since the switch takes multiple inputs for one human switch toggle, the logic was built in a way using previous and current switch inputs to toggle these values.
\pagebreak

\subsubsection{Liquid-crystal display}:
The Hitachi HD44780-based 16x2 LCD is interfaced with the LPC4088 microcontroller using GPIO pins for data signals, control signals, and power connections (VCC and GND) \cite{hd44780-datasheet}. The microcontroller will send commands and data to the LCD in order to display the decoded output to the user.

\subsubsection{Feedback LEDs}:
Two LEDs connected through the GPIO pins will provide visual user feedback on the system state. A green LED will indicate that the system is in a safe defined state, whilst a red LED will indicate an error.

\emph{Note: All additional hardware components were sourced by the Computer Engineer through the electronics supplier 'Fabian Enterprises Ltd'}

\subsection{Interrupt-Driven Sampling}
The system will be multithreaded by emulating two threads, a read and a decode (main) thread, through the use of a timer that calls an interrupt handler that triggers the ADC to sample the input signal at a frequency of at least 3266Hz. The sample rate was chosen based on the Nyquist theorem, which states that the rate should be at least twice the highest frequency of the signal, for accurate measurement.

\subsection{Buffer store}
Each captured sample is immediately stored in a circular buffer on the system's RAM which overwrites the oldest data once full capacity has been reached.

\begin{figure*}[!ht]
   \centering
   \includegraphics[width=1\textwidth]{UML.png}
   \caption{UML Diagram of Required Components / Classes}
   \hrulefill
\end{figure*}

\subsection{Functional Requirements}
\begin{description}
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} Solution must be real-time; reacting to one or more inputs that can change at any time.\vspace{2mm}}] \underline{Description:} The system will constantly read input signals, allow the user to clear display, and set configurations using a switch. Using the ARM MDK this will either be done in the main loop through constant checks or through interrupts. In this way, the system can react to real time inputs.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must make use of at least one digital input.\vspace{2mm}}] \underline{Description:} The system will contain a switch with multiple functionalities. A press clears the LCD display, thus resetting it for a new input sequence, and a toggle-up enables/disables automatic scrolling. Using the MDK this will be achieved using the GPIO drivers which facilitate configuring and using inputs such as switches.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must make use of at least one digital output.\vspace{2mm}}] \underline{Description:} The system will make use of two LEDs (1 red and 1 green) to provide immediate visual feedback of the system status. Under normal and safe operation, the green LED emits light. Upon detection of any error (such as decoding failure), the red LED will instead emit light. This will be done through the MDK's GPIO drivers which provide control to the LEDs' on and off state.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must connect to at least one external peripheral.\vspace{2mm}}] \underline{Description:} A Hitachi HD44780-based 16x2 LCD display will be used to output the decoded result. This can be achieved through manipulating GPIO pins to communicate with the LCD. These are pin P1\mathunderscore24 (used for serial data input), pin P1\mathunderscore20 (acts as the clock signal for synchronizing data transmission) and pin P1\mathunderscore2 (signals the transfer of data from the shift register to the output latches).
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} On power up or reset, system should enter a well‚Äêdefined safe state.\vspace{2mm}}] \underline{Description:} The aim is that using the MDK, routines will be defined to only respond to valid inputs, thus the system will be designed to never enter an undefined state.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must persistently store configuration settings, independent of the position of physical switches.\vspace{2mm}}] \underline{Description:}  The ARM MDK supports interfacing with non-volatile memory devices such as flash memory and EEPROMs. Thus either one will be used in order to keep track of the configurations set by the user.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System shall have a useful and appropriate mechanism for indicating error conditions to the user.\vspace{2mm}}] \underline{Description:} As mentioned previously, a red LED will be controlled using the MDK to indicate that the system has encountered an error.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System should be robust (incorrect input is handled)\vspace{2mm}}] \underline{Description:} In the event of incorrect input, the system will ignore the input without performing any action, ensuring that it remains in a stable and expected state.
\end{description}

\subsection{Steps required for decoding a signal}
\begin{enumerate}
   \item Analogue-to-digital conversion: Continuous analog signals are sampled using the ADC and stored in the RAM buffer.
   \item Noise filtering using convolution: In order to enhance signal a filter is applied such that only frequencies within the DTMF range are allowed.
   \item Breaking up the frequency: In order to identify the two frequencies making up the signal, either the Goertzel algorithm or the Fast Fourier Transform will be used.
   \item Map frequencies to digits: Once a pair of frequencies has been obtained, they are matched to the corresponding result using a lookup table. For example, the frequency pair 697, and 1209 corresponds to the digit '1'.
   \item Output Display: The decoded result is then sent directly to the display module's memory such that it is displayed to the user in real time.
\end{enumerate}

\section{EEPROM Driver and Persistant Memory}
In the functional requirements, it was stated that a persistant storage method for a system configuration setting must be in place. This storage method must be seperate from a physical state, for instance the state of a hardware switch.But rather a read/write value that can be changed by the user and stored in memory.\\

In the ARM Cortex M4, there are two methods of persistant storage flash and EEPROM. Flash is a non-volatile memory that can be written to, but has a limited number of write cycles. EEPROM is a non-volatile memory that can be written to and has a much higher number of write cycles. The EEPROM was chosen as the persistant storage method for the project.\\

Therefore, the need for an EEPROM driver was required. The value decided on to be stored, was that of the autoscroll flag. The autoscroll flag is a boolean value that determines if the system LCD display should shift the text up and continue on a new line or clear the screen and start from the top again. The autoscroll feature is user initiated/toggled through the multi-directional switch input of an up direction. Since this value is only a flag the minimum required storage fucntionaliy of EEPROM was chosen to store the byte flag.\\

The EEPROM driver was sourced from NXP MCU SW Application Team and modified for the porject specifications. The driver fucntions included the following:

\subsection{EEPROM Initiator}
The EEPROM initiator function was used to initialize the EEPROM driver. The function was called at the start of the program to ensure that the driver works in divisions of the main system clock and to set the respective wait states for the EEPROM. 

\subsection{EEPROM Read}
The EEPROM read function was used to read the chosen address of the flag value. The function takes four parameters the eeprom page offset, the page address, the pointer to the data to be read into and the length of the data to be read.\\

The function begins by clearing the interrupt flag and setting the respective page address and offsets of the EEPROM to be read from. The EEPROM is set into read mode and an iterative loop is used to read the data into the pointer. The loop consists of waits for the EEPROM status to be ready from the read and a page overflow check. Note since we are only reading a byte from a given page the page overflow check should never be triggered, but is included for completeness of the driver. We are also only reading in the 8 bit mode of the EEPROM. However, it is caple of also reading in 16 bit and 32 bit modes. The function then returns the data read into the pointer and the autoscroll flag is read and set accordingly in the main program.

\subsection{EEPROM Write}
The EEPROM write function was used to write to the chosen address, the autoscroll flag value when updated. The function takes the same four parameters as the read function.\\

The function begins and functions very similarly to the read function. It begins by clearing the interrupt flag and setting the respective page address and offsets of the EEPROM to be written to. The EEPROM is set into write mode and an iterative loop is used to write the data from the pointer. The loop consists of waits for the EEPROM status to be ready from the write and a page overflow check. Once again since we are only writing in the 8 bit mode and only a byte is to be written, the page overflow check should never be triggered. \\

The fucntion then sets the interrupt flag to wait for the end of the program, it then sets the respective address page written to at the end and we must erase the program page to ensure that the only the data written is stored and done so correctly. The function waits till the end of the program and does not need to return any data. 

\subsection{EEPROM Erase}
The EEPROM erase function was used to erase the chosen address. The erase function is essential in EEPROM logic to ensure that the data written is the only data stored in the address. This function will preceed the write function. The function takes the page address to be erased as a parameter.\\

The function begins by setting the interrupt flag to wait for the end of the program, it then sets the respective address page to be erased. The function works by wrtitng zero to the data in the page address. The function then waits till the end of the program and does not need to return any data.
\pagebreak

\section{Error State}
Another specifications of the project was to indentitfy and indicate any error conditions that may arise. The error condition identified was the case when two high freqeucies or two low frequencies are inputed into the system. The DTMF decoder will still decode these signasl being a fourier transform function but the process will simply not be able to identify the signal. When this is the case, an error case symbol is passed through '!' the main function and the system will indicate that an error has occured. The error state is indicated by the LED flashing red and the LCD displaying a '!' symbol.\\

As previously mentioned, when an error state of such nature occures the program will not hault as the DTMF decoder still processes the freqeucies. Therefore, following an error stats and indication, the system will contiue to decode as expected keeping the same complete state it was in precceding the error state. Note when such and error is encountered, depending on how the signal is passed there might be some missed DTMF codes. That is if a DTMF signal is played in sequence with a high/low frequency producing signal. The DTMF signals at which the second signal also occurs will be missed. This is the identified error condition and the system will indicate this to the user.
\pagebreak

\section{Management}
\subsection{Time Plan and Dependencies}
We have identified 11 tasks which need to be tackled. These tasks can be seen in the legend on the left-hand side of the Gantt Chart\cite{GANTT_Wikipedia} figure (Fig \ref*{figure:ganttChart}).

\begin{figure}[!ht]
   \centering
   \includegraphics[width=0.45\textwidth]{GanttChart.png}
   \caption{Gantt Chart showing our proposed time plan}
   \label{figure:ganttChart}
\end{figure}

The required responsibilities were assigned among the members of the group. These responsibilities may be subject to changes as we proceed further. Below is a breakdown of our planned assignments:

\begin{enumerate}
   \item Graham Pellegrini is assigned: Primarily the External Audio Input Circuit, Secondarily EEPROM driver, Thirdly The Decoding Algorithm, Fourth the LED operations, Error state and ADC Potentiometer configurations.
   \item Luca Vella is assigned: Primarily ADC Sampling, Secondarily Mapping to Characters, LED Operation.
   \item Matthew Mifsud is assigned: Primarily Displaying to Screen, Secondarily ADC Sampling, Thirdly Switch Operation.
   \item Julian Falzon is assigned: Primarily the Decoding Algorithm, Secondarily Configuration Settings.
\end{enumerate}

By 'Further Additions' we are referring to the implementation of any extra features that are not crucial to the functionality of the core DTMF decoder.
On the other hand, by 'Refinements' we mean optimization and refactoring of the code.
Thus, there will be no particular individual assigned for these tasks.

It should be noted that the tasks in the chart were chosen to have a one or two-week deadline, with the decoding algorithm taking three weeks, depending on the complexity of the task.

The tasks in the chart are staggered such that they partially depend on the tasks above.
The arrows within the chart illustrate which parts require full functionality of a particular task before being able to move forward.
For example, a portion of task 2 depends on task 1, this could be the testing of whether input can be read.

\subsection{Development Model}
The Rapid Software Development model is selected for this project. This model involves dividing the project into smaller, manageable parts that can be developed and tested in brief, iterative cycles. Thus emphasizing speedy development, which is a fitting choice since some decisions may change and evolve.
\cite{RapidDev}

\section{Closure}
In conclusion, this design brief has outlined the challenges to be tackled and initiated a plan for solutions to meet all requested requirements. Preliminary specifications for implementation have been set in order to do so. It is important to note that these specifications, such as error handling, the structure of component classes, and other proposed solutions may be restructured or better adapted later on in the implementation timeline. Tasks have also been set out individually, however, a collaborative effort is expected from all members in order to enable more effective problem-solving.

\bibliographystyle{ieeetr}
\bibliography{references}

\end{document}