\documentclass{cce2014-design}
\svnInfo $Id$

% Document details
\title{Design Brief: Group 5}
\author{
   Matthew Mifsud,
   Luca Vella,
   Graham Pellegrini,
   Julian Falzon
   }
\date{\svnMaxToday, Document v.\svnInfoMaxRevision}

\begin{document}

\maketitle

\abstract{%
   This documentation outlines the design of a project utilizing the LPC4088 microcontroller to interpret telephone keypad presses, also known as Dual-Tone Multi-Frequency (DTMF) signals. The LPC4088 will sample and process these signals, enabling the display of results on an LCD and feedback through two status LEDs. Additionally, users will be able to control the display state using a switch
}

\section{Introduction}


Dual-tone multi-frequency (DTMF) signaling is a method used in telecommunication systems to transmit digits or symbols over telephone lines.
Pairs of audio frequencies are used to represent each symbol;
digits 0-9, letters A-D, and special characters * and \#.
The pair of frequencies are split into groups of low and high frequencies.
These signal frequency ranges are set in the audible tones of the voice frequency range \cite{DTMF_Wikipedia}.

\begin{table}[h!]
   \begin{center}
      \begin{tabular}{ |c|c|c|c|c| }
         \hline
         FreqBand & 1209Hz & 1336Hz & 1477Hz & 1633Hz \\
         697Hz    & 1      & 2      & 3      & A      \\
         770Hz    & 4      & 5      & 6      & B      \\
         852Hz    & 7      & 8      & 9      & C      \\
         941Hz    & *      & 0      & \#     & D      \\
         \hline
      \end{tabular}
   \end{center}
   \caption{Frequency mappings}
   \label{table:frequencies}
\end{table}

The project assigned aims to build a DTMF decoder around an ARM Cortex‐M4 microcontroller.
Where the base implementation should be able to take a line‐level audio input of known fixed tone duration, decode this input and display the corresponding result to the external LCD screen at real time.

The design should follow an ordered sequence of execution.
This documentation seeks to give a high-level view of the design overview. Following the sequence of execution respectively and briefing each step of the design to provide understanding on the holistic approach to the problem.


\section{System Design}
\subsection{Hardware Components}
\textbf{Line output to ADC Circuit (input)}

DTMF audio source will be sent from Laptop using headphone jack line output to ADC. The audio signals used for testing and implementation will be those sourced from VLE as .mp3 files with variation in signal properties.
However, since line output signals vary nominally between approximately -1V to 1V and the wanted ADC signal to be processed is needed to vary from 0V to Vref  (where Vref is the working voltage from the microcontroller LPC4088) then an intermediate circuit needs to be built \cite{ADC_stackexchange}.

\begin{figure}[h!]
   \centering
   \includegraphics[width=0.5\textwidth]{ADC_Circuit.png}
   \caption{Line output to ADC}
\end{figure}


Let us break the circuit down:
\begin{itemize}
   \item The audio line output signal is connected to the circuit.
   \item This is passed serially through a 100nF capacitor which acts as an open circuit for the DC component of the signal. Thereby, allowing only the AC component of the signal to pass.
   \item A serial 100-ohm resistor is used to simply limit circuit current.
   \item At the first junction a voltage divider containing two 10K-ohm resistors is used \cite{VoltageDividerWiki}.Halving the input voltage range spanning from Vref to ground and placing the singal withing a suitable ADC range.
   \item A parallel second junction to the voltage divider of two respective 1N4148 diodes is used to protect the circuit from overvoltage (falling outside the ADC range) \cite{1n4148-datasheet}. If one input exceeds the ADC range then the opposite polar diode will begin to conduct and negate the excess voltage.
   \item Finally an ADC appropriate signal has been achieved from the original line output.
\end{itemize}

\begin{figure}[h!]
   \centering
   \includegraphics[width=0.4\textwidth]{LinetoADC.png}
   \caption{Line and ADC signals}
\end{figure}


The circuit described serves as an input conditioning stage for the audio signal before it enters the WM8731 codec. The ADC in the WM8731 converts the analogue audio signal into digital format, which can then be processed digitally by a microcontroller. The values produced by the on board Codec can be directly read through the memory-mapped I/O on the LPC4088 microcontroller board.

\textbf{User Interaction Switch}

A switch used to facilitated the requisite user interaction. The switch controlls system settings and clears the LCD. GPIO pins connect the switch the LPC4088 microcontroller, which in turn monitors the state of the switch and takes appropriate actions based on user input.

\textbf{Liquid-crystal display}

The Hitachi HD44780-based 16x2 LCD is interfaced with the LPC4088 microcontroller using GPIO pins for data signals, control signals and power connections (VCC and GND) \cite{hd44780-datasheet}.The microcontroller sends commands and data to the LCD to display user information.

\textbf{Feedback LEDs}

Two LEDs connected through the GPIO pins too, provide visual user feedback on the system state.\\
\emph{Note: All additional hardware components where sourced by Computer Engineer through the electronics supplier 'Fabian Enterprises Ltd'}

\subsection{Interrupt-Driven Sampling}

The system will make use of a timer to generate interrupts at a frequency of at least 3266Hz and each interrupt will trigger the ADC to capture a sample of the input signal. The sample rate was chosen based on the Nyquist theorem, which states that the rate should be at least twice the frequency of the signal, for accurate measurement. \\

\subsection{Buffer store}

Each captured sample is immediately stored in a circular buffer on the system's RAM which overwrites the oldest data once full capacity has been reached.

\subsection{Functional Requirements}
\begin{description}
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} Solution must be real-time; reacting to one or more inputs that can change at any time.\vspace{2mm}}] \underline{Description:} The system will constantly read input signals, allow the user to clear display and set configurations using a switch. The ARM MDK allows for the prioritization of tasks, including the constant reading of input signals, through pre-emptive multitasking. In this way, the system can react to real time inputs.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must make use of at least one digital input.\vspace{2mm}}] \underline{Description:} The system will contain a switch with multiple functionalities. A long press clears the LCD display, thus resetting it for a new input sequence and toggle up, enables automatic scrolling. Using the MDK this will be achieved using its peripheral drivers that abstract the complexity of configuring and using inputs such as switches.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must make use of at least one digital output.\vspace{2mm}}] \underline{Description:} The system will make use of two LEDs (1 red and 1 green) to provide immediate visual feedback of the system status. Under normal and safe operation, the green LED emits light. Upon detection of any error (such as decoding failure) the red LED will instead emit light. This will be done through the MDK's libraries which provide control the LEDs' on and off state.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must connect to at least one external peripheral.\vspace{2mm}}] \underline{Description:} A Hitachi HD44780-based 16x2 LCD display will be used to output the decoded result. The MDK supports a number of communication interfaces such as I2C, UART and SPI which can be used to communicate with the LCD.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} On power up or reset, system should enter a well‐defined safe state.\vspace{2mm}}] \underline{Description:} The aim is that using the MDK routines will be defined to only respond to valid inputs, thus the system will be designed to never enter an undefined state.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System must persistently store configuration settings, independent of the position of physical switches.\vspace{2mm}}] \underline{Description:}  The ARM MDK supports interfacing with non-volatile memory devices such as flash memory and EEPROMs. Thus either one will be used in order to keep track of the configurations set by the user.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System shall have a useful and appropriate mechanism for indicating error conditions to the user.\vspace{2mm}}] \underline{Description:} As mentioned prior, a red LED will be controlled using the MDK to indicate that the system has encountered an error.
   \item[\parbox{0.5\textwidth}{\underline{Requirement:} System should be robust (incorrect input is handled)\vspace{2mm}}] \underline{Description:} In the event of incorrect input, the system will ignore the input without performing any action, ensuring that it remains in a stable and expected state.

\end{description}

\subsection{Steps required for decoding a signal}
\begin{enumerate}
   \item Analogue-to-digital conversion: Continuous analogue signals are sampled using the ADC and stored in the RAM buffer.
   \item Noise reduction using convolution filtering: In order to enhance signal a filter is applied such that only frequencies within the DTMF range are allowed.
   \item Breaking up the frequency: In order to identify the two frequencies making up the signal, either the Goertzel algorithm or the Fast Fourier Transform will be used. This is because of their efficient and accurate detection of the tone pairs.
   \item Map frequencies to digits: Once a pair of frequencies has been obtained, they are matched to the corresponding result using a lookup table stored in flash memory since only reading is required. Example, the frequency pair 697 Hz and 1209 Hz corresponds to the digit '1'.
   \item Output Display: The decoded result is then sent directly to the display module from the buffer such that it is displayed to the user in real-time.
\end{enumerate}

\section{Management}

We believe that there are 8 tasks which we should focus our attention on. These tasks can be seen in the legend on the left hand side of the Gantt Chart\cite{GANTT_Wikipedia} figure (Fig \ref*{figure:ganttChart}).

\begin{figure}[h!]
   \centering
   \includegraphics[width=0.5\textwidth]{GanttChart.png}
   \caption{Gantt Chart showing our proposed time plan}
   \label{figure:ganttChart}
\end{figure}

We have already allocated who is responsible for each task among ourselves. Below is a breakdown of our assignments:

\begin{enumerate}
   \item Graham Pellegrini is assigned: Primarily the External Audio Input Circuit (1), Secondarily Signal Cleaning (3), Thirdly The Decoding Algorithm
   \item Luca Vella is assigned: Primarily ADC Sampling (2), Secondarily Mapping to Characters (5), LED Operation.
   \item Matthew Mifsud is assigned: Primarily Displaying to Screen (6), Secondarily ADC Sampling (2), Thirdly Switch Operation.
   \item Julian Falzon is assigned: Primarily the Decoding Algorithm (4), Secondarily Configuration Settings.
\end{enumerate}

\begin{figure*}[ht!]
   \centering
   \includegraphics[width=\textwidth]{UML.png}
   \caption{UML Diagram of Required Components / Classes}
   \hrulefill
\end{figure*}


Of note, tasks 7 and 8 are general task.
Task 7 will cover implementing any extra features that are not cruical to the functionality of the DTMF decoder.
Whilst task 8 is optimisation and refactoring of the code.
Thus, there is no particular assignment for each of them as of now.

It is of note that the tasks in the chart were chosen to have a one week deadline or three week deadline depending on the complexity of the task.

The period for the task begins on the day of the meeting, which is Wednesday in our case, and extends until the meeting occurs in its designated deadline week.

The tasks in the chart are staggered such that they depend on the tasks above them before they can be done. For example, task 2 depends on task 1 to be able to read an input.

\section{Closure}
In conclusion, this design brief has outlined the project’s problems to be tackled and the initial planning for implementing solutions and concepts to meet the functional requirements realised by the ARM MDK. This brief sets preliminary specifications for implementation depending on assignment requirements. However, these specifications, such as error handling and the structure of component classes, may be restructured or better adapted later on in the implementation timeline. Management tasks have been set out individually in advance of delivering solutions, but members seek a collaborative effort to enhance problem-solving techniques used.

\bibliographystyle{ieeetr}
\bibliography{references}


Make sure to mention the process that will be done on each individual sample "block",
where you talk about after what amount of time will you handle proccessing and what is the processing of a block.

ADC will collect only one sample, make sure to tell the ADC to sample after a given period using something like a interrupt from a timer.

In general the sample of a signal will be twice or more the frequeny.

Talk about how you will handle the system in real time.
Mentioning how to you have to seperate a thread to handle the saving and getting of the data from the ADC ( Analog digital converter ), and a "concurrent" thread to handle the processing of an already in store memory block.

We may include images in the system design the explain the workflow and data flow and control flow of the system.


\end{document}