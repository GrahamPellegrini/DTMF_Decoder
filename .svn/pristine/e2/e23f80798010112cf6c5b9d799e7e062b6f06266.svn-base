#include <adc.h>
#include <platform.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <timer.h>
#include "DTMF.h"
#include "delay.h"
#include "lcd.h"
#include "leds.h"
#include "switches.h"

#include <stdlib.h>  // Required for rand() and srand()

#define BUFFER_SIZE 32
#define SAMPLE_RATE 500

int buffer1[BUFFER_SIZE];

int buffer2[BUFFER_SIZE];

char secondRowOutput[BUFFER_SIZE / 2 + 1];

int secondRowPosition = 0;

int* currentBuffer = buffer1;

unsigned int currentBufferPosition = 0;

unsigned int cursorPosition = 0;

bool isBufferFull = false;

bool autoScroll = false;

char decodedResult = '\0';

void samplingInterrupt(void);

void detectSwitchInput(void);

char getMockDecodedResult(void);

char prevdecodedResult;
int lowest = 0, highest = 0;
int lowest_freq = 0, highest_freq = 0;

MyObject low_freq[4], high_freq[4];
const double low[4] = { 697, 770, 852, 941 };
const double high[4] = { 1209, 1336, 1477, 1633 };

double temp = 0;

int main(void) {
  adc_init();
  lcd_init();
  leds_init();
  switches_init();
  lcd_clear();
  lcd_print("DTMF Decoder");
  delay_ms(1000);
  lcd_clear();

  for (int i = 0; i < 4; ++i) {
    init(&low_freq[i], low[i], 8000);
    init(&high_freq[i], high[i], 8000)
  }

  timer_init(CLK_FREQ / SAMPLE_RATE);
  timer_set_callback(&samplingInterrupt);
  timer_enable();

  while (1) {
    detectSwitchInput();

    if (cursorPosition == 16) {
      lcd_set_cursor(0, 1);
    }

    if (isBufferFull) {
      isBufferFull = false;
      if (currentBuffer == buffer1) {
        currentBuffer = buffer2;
      } else {
        currentBuffer = buffer1;
      }
      // Start of decoded algorithm
      if (quietDetection(currentBuffer, 0, BUFFER_SIZE) < QUIET_THRESHOLD) {
        decodedResult = '';
        continue;
      }

      // Low freq
      for (int i = 0; i < 4; ++i) {
        temp = processSample(currentBuffer, 0, BUFFER_SIZE, low_freq[i]);
        if (temp > lowest) {
          lowest = temp;
          lowest_freq = low_freq[i].frequency;
        }
      }

      // High freq
      for (int i = 0; i < 4; ++i) {
        temp = processSample(currentBuffer, n, n + N, high_freq[i]);
        if (temp > highest) {
          highest = temp;
          highest_freq = high_freq[i].frequency;
        }
      }

      prevdecodedResult = decodedResult;
      decodedResult = toneDetection(lowest_freq, highest_freq);

      // End of decode
      if (prevdecodedResult == decodedResult) {
        continue;
      }

      if (cursorPosition == 33) {
        if (autoScroll) {
          lcd_clear();
          cursorPosition = 0;
          lcd_print(secondRowOutput);
          cursorPosition = 16;
        }
      } else {
        lcd_put_char(decodedResult);
        cursorPosition++;
      }

      if (cursorPosition > 16 && cursorPosition < 33) {
        secondRowOutput[secondRowPosition] = decodedResult;
        secondRowPosition++;
      } else if (cursorPosition == BUFFER_SIZE + 1) {
        secondRowOutput[16] = '\0';
        secondRowPosition = 0;
      }
    }
  }

  void samplingInterrupt() {
    const int res = adc_read();

    if (currentBufferPosition >= BUFFER_SIZE) {
      isBufferFull = true;
      currentBufferPosition = 0;
      return;
    }

    if (currentBuffer == buffer1) {
      buffer1[currentBufferPosition] = res;
    } else {
      buffer2[currentBufferPosition] = res;
    }

    currentBufferPosition++;
  }

  void detectSwitchInput() {
    // light_leds();
    if (switch_get(P_SW_UP)) {
      if (!autoScroll) {
        leds_set(0, 0, 1);
        autoScroll = true;
      } else {
        leds_set(0, 0, 0);
        autoScroll = false;
      }

      delay_ms(500);  // Debounce delay
    } else if (switch_get(P_SW_CR)) {
      leds_set(0, 1, 0);
      lcd_clear();
      cursorPosition = 0;
      if (autoScroll) {
        leds_set(0, 0, 1);
      } else {
        leds_set(0, 0, 0);
      }

    } else if (switch_get(P_SW_DN)) {
      exit(0);
    } else if (switch_get(P_SW_LT)) {
      exit(0);
    } else if (switch_get(P_SW_RT)) {
      exit(0);
    }
  }

  char getMockDecodedResult() {
    const char pi_digits[] = "31415926535897932384626433832795";
    int index = rand() % 32;
    return pi_digits[index];
  }
